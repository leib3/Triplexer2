#include <ADC.h>
#include <TimeLib.h>

const int readPin = A9; // ADC0
const int readPin2 = A2; // ADC1

ADC *adc = new ADC(); // adc object;

void setup() {

  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(readPin, INPUT);
  pinMode(readPin2, INPUT);

  pinMode(A10, INPUT); //Diff Channel 0 Positive
  pinMode(A11, INPUT); //Diff Channel 0 Negative
#if ADC_NUM_ADCS>1
  pinMode(A12, INPUT); //Diff Channel 3 Positive
  pinMode(A13, INPUT); //Diff Channel 3 Negative
#endif

  Serial.begin(9600);

  Serial.println("Begin setup");

  ///// ADC0 ////
  // reference can be ADC_REFERENCE::REF_3V3, ADC_REFERENCE::REF_1V2 (not for Teensy LC) or ADC_REFERENCE::REF_EXT.
  //adc->setReference(ADC_REFERENCE::REF_1V2, ADC_0); // change all 3.3 to 1.2 if you change the reference to 1V2

  adc->setAveraging(16); // set number of averages
  adc->setResolution(16); // set bits of resolution

  // it can be any of the ADC_CONVERSION_SPEED enum: VERY_LOW_SPEED, LOW_SPEED, MED_SPEED, HIGH_SPEED_16BITS, HIGH_SPEED or VERY_HIGH_SPEED
  // see the documentation for more information
  // additionally the conversion speed can also be ADACK_2_4, ADACK_4_0, ADACK_5_2 and ADACK_6_2,
  // where the numbers are the frequency of the ADC clock in MHz and are independent on the bus speed.
  adc->setConversionSpeed(ADC_VERY_HIGH_SPEED); // change the conversion speed
  // it can be any of the ADC_MED_SPEED enum: VERY_LOW_SPEED, LOW_SPEED, MED_SPEED, HIGH_SPEED or VERY_HIGH_SPEED
  adc->setSamplingSpeed(ADC_VERY_HIGH_SPEED); // change the sampling speed

  // always call the compare functions after changing the resolution!
  //adc->enableCompare(1.0/3.3*adc->getMaxValue(ADC_0), 0, ADC_0); // measurement will be ready if value < 1.0V
  //adc->enableCompareRange(1.0*adc->getMaxValue(ADC_0)/3.3, 2.0*adc->getMaxValue(ADC_0)/3.3, 0, 1, ADC_0); // ready if value lies out of [1.0,2.0] V

  // If you enable interrupts, notice that the isr will read the result, so that isComplete() will return false (most of the time)
  //adc->enableInterrupts(ADC_0);


  ////// ADC1 /////
#if ADC_NUM_ADCS>1
  adc->setAveraging(16, ADC_1); // set number of averages
  adc->setResolution(16, ADC_1); // set bits of resolution
  adc->setConversionSpeed(ADC_VERY_HIGH_SPEED, ADC_1); // change the conversion speed
  adc->setSamplingSpeed(ADC_VERY_HIGH_SPEED, ADC_1); // change the sampling speed

  //adc->setReference(ADC_REFERENCE::REF_1V2, ADC_1);

  // always call the compare functions after changing the resolution!
  //adc->enableCompare(1.0/3.3*adc->getMaxValue(ADC_1), 0, ADC_1); // measurement will be ready if value < 1.0V
  //adc->enableCompareRange(1.0*adc->getMaxValue(ADC_1)/3.3, 2.0*adc->getMaxValue(ADC_1)/3.3, 0, 1, ADC_1); // ready if value lies out of [1.0,2.0] V


  // If you enable interrupts, note that the isr will read the result, so that isComplete() will return false (most of the time)
  //adc->enableInterrupts(ADC_1);

#endif

  Serial.println("End setup");

}

float Ma, Mb, Mc, Md, CMx, CMy, TM, TM1, TM2, MaxW;
int Cal = 1, InvX=0, InvY=0, InvT=0;

const int x = 6;
const int y = 12;

void loop() {
  // put your main code here, to run repeatedly:

  if (Cal == 1) {
    Calibrate();
    Cal = 0;
  }
  //Serial.print("Start time: ");
  //Serial.println( micros());
  Ma = adc->analogRead(A0);
  Mb = adc->analogRead(A1);
  Mc = adc->analogRead(A2);
  Md = adc->analogRead(A3);
  CMx = (Mb * x + Mc * x) / (Ma + Mb + Mc + Md);
  CMy = (Ma * y + Mb * y) / (Ma + Mb + Mc + Md);
  TM = Ma + Mb + Mc + Md;
  CMx = (127 * CMx) / 6;
  CMy = (127 * CMy) / 12;
  if(TM>MaxW){
    TM=MaxW;
  }
  TM = (127 * TM) / MaxW;
  if(InvX==1){
    CMx=127-CMx;
  }
  if(InvY==1){
    CMy=127-CMy;
  }
  if(InvT==1){
    TM=127-TM;
  }
  Serial.print("Center of mass x =");
  Serial.println(CMx);
  Serial.print("Center of mass y =");
  Serial.println(CMy);
  Serial.print("Total mass =");
  Serial.println(TM);
  //Serial.print("End time: ");
  //Serial.println(micros());
  delay(1000);
}

void Calibrate() {
  while (1) {
    Serial.println("Calibrating...");
    Ma = adc->analogRead(A0);
    Mb = adc->analogRead(A1);
    Mc = adc->analogRead(A2);
    Md = adc->analogRead(A3);
    TM1 = Ma + Mb + Mc + Md;
    delay(2000);
    Ma = adc->analogRead(A0);
    Mb = adc->analogRead(A1);
    Mc = adc->analogRead(A2);
    Md = adc->analogRead(A3);
    TM2 = Ma + Mb + Mc + Md;
    if (TM1 == TM2) {
      MaxW = TM1;
      return;
    }
  }
}



#include <ADC.h>
#include <TimeLib.h>

const int readPin = A9; // ADC0
const int readPin2 = A2; // ADC1

ADC *adc = new ADC(); // adc object;

void setup() {

  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(readPin, INPUT);
  pinMode(readPin2, INPUT);

  pinMode(A10, INPUT); //Diff Channel 0 Positive
  pinMode(A11, INPUT); //Diff Channel 0 Negative
#if ADC_NUM_ADCS>1
  pinMode(A12, INPUT); //Diff Channel 3 Positive
  pinMode(A13, INPUT); //Diff Channel 3 Negative
#endif

  Serial.begin(9600);

  Serial.println("Begin setup");

  ///// ADC0 ////
  // reference can be ADC_REFERENCE::REF_3V3, ADC_REFERENCE::REF_1V2 (not for Teensy LC) or ADC_REFERENCE::REF_EXT.
  //adc->setReference(ADC_REFERENCE::REF_1V2, ADC_0); // change all 3.3 to 1.2 if you change the reference to 1V2

  adc->setAveraging(4); // set number of averages
  adc->setResolution(16); // set bits of resolution

  // it can be any of the ADC_CONVERSION_SPEED enum: VERY_LOW_SPEED, LOW_SPEED, MED_SPEED, HIGH_SPEED_16BITS, HIGH_SPEED or VERY_HIGH_SPEED
  // see the documentation for more information
  // additionally the conversion speed can also be ADACK_2_4, ADACK_4_0, ADACK_5_2 and ADACK_6_2,
  // where the numbers are the frequency of the ADC clock in MHz and are independent on the bus speed.
  adc->setConversionSpeed(ADC_VERY_HIGH_SPEED); // change the conversion speed
  // it can be any of the ADC_MED_SPEED enum: VERY_LOW_SPEED, LOW_SPEED, MED_SPEED, HIGH_SPEED or VERY_HIGH_SPEED
  adc->setSamplingSpeed(ADC_VERY_HIGH_SPEED); // change the sampling speed

  // always call the compare functions after changing the resolution!
  //adc->enableCompare(1.0/3.3*adc->getMaxValue(ADC_0), 0, ADC_0); // measurement will be ready if value < 1.0V
  //adc->enableCompareRange(1.0*adc->getMaxValue(ADC_0)/3.3, 2.0*adc->getMaxValue(ADC_0)/3.3, 0, 1, ADC_0); // ready if value lies out of [1.0,2.0] V

  // If you enable interrupts, notice that the isr will read the result, so that isComplete() will return false (most of the time)
  //adc->enableInterrupts(ADC_0);


  ////// ADC1 /////
#if ADC_NUM_ADCS>1
  adc->setAveraging(4, ADC_1); // set number of averages
  adc->setResolution(16, ADC_1); // set bits of resolution
  adc->setConversionSpeed(ADC_VERY_HIGH_SPEED, ADC_1); // change the conversion speed
  adc->setSamplingSpeed(ADC_VERY_HIGH_SPEED, ADC_1); // change the sampling speed

  //adc->setReference(ADC_REFERENCE::REF_1V2, ADC_1);

  // always call the compare functions after changing the resolution!
  //adc->enableCompare(1.0/3.3*adc->getMaxValue(ADC_1), 0, ADC_1); // measurement will be ready if value < 1.0V
  //adc->enableCompareRange(1.0*adc->getMaxValue(ADC_1)/3.3, 2.0*adc->getMaxValue(ADC_1)/3.3, 0, 1, ADC_1); // ready if value lies out of [1.0,2.0] V


  // If you enable interrupts, note that the isr will read the result, so that isComplete() will return false (most of the time)
  //adc->enableInterrupts(ADC_1);

#endif

  Serial.println("End setup");

}

float CMx, CMy, TM, MaxW, MinW;
int Cal = 1, InvX=0, InvY=0, InvT=0, Max=65535;
unsigned int Ma, Mb, Mc, Md;

const int x = 6;
const int y = 12;

void loop() {
  // put your main code here, to run repeatedly:

  if (Cal == 1) {
    Calibrate();
    Cal = 0;
  }
  Serial.print("Start time: ");
  Serial.println( micros());
  /*Ma = adc->analogRead(A0);
  Mb = adc->analogRead(A1);
  Mc = adc->analogRead(A2);
  Md = adc->analogRead(A3);*/
  ADC::Sync_result result = adc->analogSyncRead(A0, A2);
  Ma=result.result_adc0;
  Mc=result.result_adc1;
  result = adc->analogSyncRead(A1, A3);
  Mb=result.result_adc0;
  Md=result.result_adc1;
  CMx=CalcX(Ma, Mb, Mc, Md, Max, InvX);
  CMy=CalcY(Ma, Mb, Mc, Md, 127, InvY);
  TM=CalcT(Ma, Mb, Mc, Md, Max, InvT);
  Serial.println(Ma);
  Serial.println(Mb);
  Serial.println(Mc);
  Serial.println(Md);
  Serial.print("Center of mass x =");
  Serial.println(CMx);
  Serial.print("Center of mass y =");
  Serial.println(CMy);
  Serial.print("Total mass =");
  Serial.println(TM);
  Serial.print("End time: ");
  Serial.println(micros());
  delay(1000);
}

void Calibrate() {
  int TM1, TM2, TM3, TM4;
  while (1) {
    Serial.println("Calibrating...");
    Ma = adc->analogRead(A0);
    Mb = adc->analogRead(A1);
    Mc = adc->analogRead(A2);
    Md = adc->analogRead(A3);
    TM1 = Ma + Mb + Mc + Md;
    delay(2000);
    Ma = adc->analogRead(A0);
    Mb = adc->analogRead(A1);
    Mc = adc->analogRead(A2);
    Md = adc->analogRead(A3);
    TM2 = Ma + Mb + Mc + Md;
    //if (TM1 == TM2) {
      MinW = TM1;
      return;
   // }
   Ma = adc->analogRead(A0);
    Mb = adc->analogRead(A1);
    Mc = adc->analogRead(A2);
    Md = adc->analogRead(A3);
    TM3 = Ma + Mb + Mc + Md;
    delay(2000);
    Ma = adc->analogRead(A0);
    Mb = adc->analogRead(A1);
    Mc = adc->analogRead(A2);
    Md = adc->analogRead(A3);
    TM4 = Ma + Mb + Mc + Md;
    //if (TM3 == TM4) {
        //if (TM3!=TM1){
           MaxW = TM3;
           return;
       // }
   // }
  }
}

int CalcX(int Ma, int Mb, int Mc, int Md, int Max, int Inv){
  int CMx;
  CMx = (Mb * x + Mc * x) / (Ma + Mb + Mc + Md); 
  CMx = (Max * CMx) / 6;
  if(Inv==1){
    CMx=Max-CMx;
  }
  return CMx;
}

int CalcY(int Ma, int Mb, int Mc, int Md, int Max, int Inv){
  int CMy;
  CMy = (Mb * y + Mc * y) / (Ma + Mb + Mc + Md); 
  CMy = (Max * CMy) / 12;
  if(Inv==1){
    CMy=Max-CMy;
  }
  return CMy;
}

int CalcT(int Ma, int Mb, int Mc, int Md, int Max, int Inv){
  unsigned int TM;
  TM = Ma + Mb + Mc + Md;
  if(TM>MaxW){
    TM=MaxW;
  }
  if(TM<MinW){
    TM=MinW;
  }
  TM = (Max * TM-MinW) / (MaxW-MinW);
  if(Inv==1){
    TM=Max-TM;
  }
  return TM;
}

